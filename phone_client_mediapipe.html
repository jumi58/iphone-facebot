<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Phone Client â€” MediaPipe Face Angle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MediaPipe JS ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    video { display:none; }
    canvas { width: 100%; max-width: 480px; height: auto; background: #000; border-radius: 8px; }
    .row { margin: 8px 0; }
    .hint { color: #666; font-size: 12px; }
    .angle { font-size: 22px; font-weight: 700; }
  </style>
</head>
<body>
  <h3>ğŸ“± Phone Client â€” MediaPipe Face Angle</h3>

  <div class="row">
    WebSocket ì„œë²„(ë…¸íŠ¸ë¶ IP):
    <input id="ws" placeholder="ws://<laptop_ip>:8765" style="width: 260px;" />
    <button id="connectBtn">ì—°ê²°</button>
    <span id="status" class="hint"></span>
  </div>

  <!-- ì¹´ë©”ë¼ ì˜ìƒì€ videoì— ë°›ê³ , ê·¸ê±¸ canvasì— ê·¸ë¦¼ -->
  <video class="input_video" id="video" playsinline></video>
  <canvas class="output_canvas" id="canvas" width="640" height="480"></canvas>

  <div class="row">
    <label><input type="checkbox" id="mirror" checked> ë¯¸ëŸ¬ ë³´ê¸°(ì…€ì¹´ì²˜ëŸ¼)</label>
    <label style="margin-left:12px;">ë¯¼ê°ë„ Î±:
      <input type="range" id="alpha" min="0.05" max="0.6" step="0.01" value="0.25">
    </label>
    <label style="margin-left:12px;">ë°ë“œë°´ë“œ:
      <input type="range" id="dead" min="0" max="0.1" step="0.005" value="0.02">
    </label>
  </div>

  <div class="angle">ANGLE: <span id="angleText">--</span>Â°</div>
  <div class="hint">
    ê°™ì€ Wi-Fiì— ìˆëŠ” ë…¸íŠ¸ë¶ IPë¥¼ ì…ë ¥ í›„ ì—°ê²°í•˜ì„¸ìš”. ì˜ˆ: <b>ws://192.168.0.15:8765</b><br>
    (WebSocketì€ ë‚˜ì¤‘ì— ESP32/ë…¸íŠ¸ë¶ ì—°ë™ìš©ì´ë¼, ì§€ê¸ˆì€ ì—°ê²° ì•ˆ í•´ë„ ì–¼êµ´ ì¸ì‹ì€ ì˜ ë©ë‹ˆë‹¤)
  </div>

<script>
const videoElement  = document.getElementById('video');
const canvasElement = document.getElementById('canvas');
const canvasCtx     = canvasElement.getContext('2d');

const wsInput    = document.getElementById('ws');
const connectBtn = document.getElementById('connectBtn');
const statusSpan = document.getElementById('status');
const angleText  = document.getElementById('angleText');
const mirrorChk  = document.getElementById('mirror');
const alphaInput = document.getElementById('alpha');
const deadInput  = document.getElementById('dead');

let lastAngle = 90;
let lastSend  = 0;
let socket    = null;

// WebSocket ì—°ê²°/í•´ì œ ë²„íŠ¼
connectBtn.onclick = () => {
  if (socket && socket.readyState === 1) {
    socket.close();
    return;
  }
  const url = wsInput.value.trim();
  if (!url) { alert("ws://<laptop_ip>:8765 í˜•ì‹ìœ¼ë¡œ ì…ë ¥"); return; }
  socket = new WebSocket(url);
  socket.onopen  = () => { statusSpan.textContent = "ì—°ê²°ë¨"; connectBtn.textContent = "ëŠê¸°"; };
  socket.onclose = () => { statusSpan.textContent = "ëŠì–´ì§"; connectBtn.textContent = "ì—°ê²°"; };
  socket.onerror = () => { statusSpan.textContent = "ì˜¤ë¥˜"; };
};

// ê°ë„ ì „ì†¡ (ESP32/ë…¸íŠ¸ë¶ ìš©)
function sendAngle(angle){
  const now = performance.now();
  if (!socket || socket.readyState !== 1) return;
  if (now - lastSend < 80) return; // ì•½ 12Hz
  lastSend = now;
  const payload = JSON.stringify({
    type: "angle",
    value: Math.round(angle),
    ts: Date.now()
  });
  socket.send(payload);
}

// MediaPipe ê²°ê³¼ ì²˜ë¦¬
function onResults(results) {
  const alpha = parseFloat(alphaInput.value);
  const dead  = parseFloat(deadInput.value);

  // ë°°ê²½ ì§€ìš°ê³  í˜„ì¬ í”„ë ˆì„ ê·¸ë¦¼
  canvasCtx.save();
  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
  canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

  const detections = results.detections;
  if (detections && detections.length > 0) {
    // ê°€ì¥ í° ì–¼êµ´ í•˜ë‚˜ ê³ ë¥´ê¸° (ê°€ê¹Œìš´ ì‚¬ëŒ)
    let best = detections[0];
    let bestArea = 0;
    detections.forEach(det => {
      const b = det.boundingBox;
      const w = b.width * canvasElement.width;
      const h = b.height * canvasElement.height;
      const area = w * h;
      if (area > bestArea) { bestArea = area; best = det; }
    });

    const box = best.boundingBox;

    // ë¹¨ê°„ ë°•ìŠ¤ ê·¸ë¦¬ê¸°
    drawingUtils.drawRectangle(
      canvasCtx,
      box,
      {color: 'red', lineWidth: 4, fillColor: '#00000000'}
    );

    // ì¤‘ì‹¬ x ì¢Œí‘œ(ì •ê·œí™” 0~1) ê°€ì ¸ì˜¤ê¸°
    let cxNorm;
    if (typeof box.xCenter === 'number') {
      cxNorm = box.xCenter; // ì´ë¯¸ 0~1
    } else {
      // xmin + width/2 í˜•íƒœì¼ ìˆ˜ë„ ìˆì–´ì„œ ëŒ€ë¹„
      cxNorm = (box.xmin || 0) + (box.width || 0) / 2;
    }

    // ë¯¸ëŸ¬ ì˜µì…˜: ì¢Œìš° ë°˜ì „
    if (!mirrorChk.checked) {
      // ë¯¸ëŸ¬ ì²´í¬ë¥¼ ë„ë©´ ì‹¤ì œ í™”ë©´ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©
      // (ì…€ì¹´ì²˜ëŸ¼ ë³´ì´ê²Œ í•˜ê³  ì‹¶ìœ¼ë©´ ì²´í¬ on ìƒíƒœ ìœ ì§€)
    } else {
      // í™”ë©´ì´ ì¢Œìš° ë’¤ì§‘í˜€ ë³´ì´ëŠ” ê²½ìš° â†’ ê°ë„ë„ ë°˜ëŒ€ë¡œ
      cxNorm = 1.0 - cxNorm;
    }

    // 0~1 ìœ„ì¹˜ë¥¼ 0~180ë„ë¡œ ë³€í™˜
    let desired = cxNorm * 180;

    // ê°€ìš´ë° ê·¼ì²˜(ë°ë“œë°´ë“œ)ëŠ” ì›€ì§ì„ ë¬´ì‹œ
    if (Math.abs(cxNorm - 0.5) < dead) {
      desired = lastAngle;
    }

    // ë¶€ë“œëŸ½ê²Œ ë³´ê°„
    const smooth = lastAngle + alpha * (desired - lastAngle);
    lastAngle = smooth;

    angleText.textContent = Math.round(smooth);
    sendAngle(smooth);
  } else {
    // ì–¼êµ´ ì—†ì„ ë•ŒëŠ” ê·¸ëƒ¥ ì´ì „ í™”ë©´ ìœ ì§€
  }

  canvasCtx.restore();
}

// MediaPipe FaceDetection ì„¤ì •
const faceDetection = new FaceDetection.FaceDetection({
  locateFile: (file) => {
    // ë¼ì´ë¸ŒëŸ¬ë¦¬ íŒŒì¼ CDNì—ì„œ ë¡œë“œ
    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
  }
});

// ì˜µì…˜: short ëª¨ë¸ + ì…€í”¼ ëª¨ë“œ + ì‹ ë¢°ë„
faceDetection.setOptions({
  model: 'short',              // ê°€ê¹Œìš´ ì–¼êµ´ìš© (ë©€ë¦¬ë©´ 'full'ë„ ê°€ëŠ¥)
  selfieMode: true,            // ì¹´ë©”ë¼ ì…€í”¼ëª¨ë“œ (ì¢Œìš° ë°˜ì „)
  minDetectionConfidence: 0.6  // ì‹ ë¢°ë„ ë†’ì¼ìˆ˜ë¡ ë” í™•ì‹¤í•œ ì–¼êµ´ë§Œ ì¡ìŒ
});

faceDetection.onResults(onResults);

// ì¹´ë©”ë¼ ì‹œì‘
const camera = new Camera(videoElement, {
  onFrame: async () => {
    await faceDetection.send({image: videoElement});
  },
  width: 640,
  height: 480
});

camera.start();
</script>
</body>
</html>
